<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈var,let,const的区别</title>
      <link href="/2022/10/28/%E5%AD%A6%E4%B9%A0/JS/%E6%B5%85%E8%B0%88var-let-const%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/10/28/%E5%AD%A6%E4%B9%A0/JS/%E6%B5%85%E8%B0%88var-let-const%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="一-var-声明存在变量提升，let和const-声明的变量则不存在变量提升"><a href="#一-var-声明存在变量提升，let和const-声明的变量则不存在变量提升" class="headerlink" title="一. var 声明存在变量提升，let和const 声明的变量则不存在变量提升"></a>一. var 声明存在变量提升，let和const 声明的变量则不存在变量提升</h3><p>例子：<br><strong>var</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//输出结果:undefind ⇒ a已经声明但是没有赋值，注意此处并没有值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>let</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//输出结果： 报错：Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initialization ==&gt; 找不到b这个变量</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>const</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//输出结果： 报错：Uncaught ReferenceError: Cannot access &#x27;c&#x27; before initialization ==&gt; 找不到c这个变量</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="二-var声明的变量会挂载到window对象之中，而let和const-声明不会"><a href="#二-var声明的变量会挂载到window对象之中，而let和const-声明不会" class="headerlink" title="二.var声明的变量会挂载到window对象之中，而let和const 声明不会"></a>二.var声明的变量会挂载到window对象之中，而let和const 声明不会</h3><p>例子:<br><strong>var</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//输出结果：a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>);<span class="comment">//输出结果：a</span></span><br></pre></td></tr></table></figure><p><strong>let</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//输出结果：c</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">c</span>);<span class="comment">//输出结果：undefind</span></span><br></pre></td></tr></table></figure><p><strong>const</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//输出结果：c</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">c</span>);<span class="comment">//输出结果：undfind</span></span><br></pre></td></tr></table></figure><p><font color=red><strong>var</strong>这种特性会造成window的全局变量污染</font>,只要我们声明的该变量名与原变量(window自带的变量)名相同的话，会出现<em>声明变量值</em>覆盖<em>原变量值</em>的现象。那么，let和const会不会出现这个问题呢？我们接着来看。</p><hr><h3 id="三-同一个作用域下，var可以重复声明变量，但是let和const不可以"><a href="#三-同一个作用域下，var可以重复声明变量，但是let和const不可以" class="headerlink" title="三.同一个作用域下，var可以重复声明变量，但是let和const不可以"></a>三.同一个作用域下，var可以重复声明变量，但是let和const不可以</h3><p>例子:<br><strong>var</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a1&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a2&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//输出结果为：a2</span></span><br></pre></td></tr></table></figure><p><font color=red>注意：var声明，后面声明的变量值，会覆盖前面的变量值</font><br><strong>let</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;b1&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//输出结果：Uncaught SyntaxError: Identifier &#x27;b&#x27; has already been declared  ==&gt; 变量 b 已经被声明了</span></span><br></pre></td></tr></table></figure><p><strong>const</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&#x27;c1&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//输出结果：Uncaught SyntaxError: Identifier &#x27;c&#x27; has already been declared  ==&gt; 变量 c 已经被声明了</span></span><br></pre></td></tr></table></figure><p><font color=red>从let和const的例子来看，let 和const 并不会造成全局变量污染的情况，但是为了避免出现全局变量污染的情况，我们尽量使用let 和 const 分别来声明 变量/常量 。</font></p><hr><h3 id="四-var声明不存在块级作用域，let和const声明-存在块级作用域"><a href="#四-var声明不存在块级作用域，let和const声明-存在块级作用域" class="headerlink" title="四.var声明不存在块级作用域，let和const声明 存在块级作用域"></a>四.var声明不存在块级作用域，let和const声明 存在块级作用域</h3><p>例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//输出结果：a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//输出结果：报错：Uncaught ReferenceError: b is not defined ==&gt; 找不到b这个变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//输出结果：报错：Uncaught ReferenceError: c is not defined ==&gt; 找不到c这个变量</span></span><br><span class="line"><span class="comment">//注意：当console.log(b)报错时，程序就不会继续进行了，这里进行了多次尝试，方便演示才输出console.log(c)的结果</span></span><br></pre></td></tr></table></figure><hr><h3 id="五-let和const的暂时死区-DTC"><a href="#五-let和const的暂时死区-DTC" class="headerlink" title="五.let和const的暂时死区(DTC)"></a>五.let和const的暂时死区(DTC)</h3><p><strong>例一：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;xichenghui&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">demo</span>();<span class="comment">//输出结果为：xichenghui</span></span><br></pre></td></tr></table></figure><p><strong>如上所示，当变量name被声明在函数外部，此时函数内部都可以直接使用</strong><br><strong>例二：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;xichenghui&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;handsomeBoy!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">demo</span>();<span class="comment">//执行函数后，控制台报错:Uncaught ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br></pre></td></tr></table></figure><p><strong><font color=red>代码解释：如果当前作用域中使用了变量name ,并且当前的块级作用域中通过 let/const 声明了该变量，</strong>那么，声明语句必须放在使用之前，也就是所谓的DTC(暂时性死区)<strong>,DTC是一种保护机制，可以让我们保持良好的编程习惯</font></strong></p><hr><h3 id="六-const-一旦声明就必须赋值；声明后就不能修改了"><a href="#六-const-一旦声明就必须赋值；声明后就不能修改了" class="headerlink" title="六.const:一旦声明就必须赋值；声明后就不能修改了"></a>六.const:一旦声明就必须赋值；声明后就不能修改了</h3><pre><code>例子：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//控制台报错：Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>&lt;hr&gt;</code></pre><h3 id="七-const-常量到能否更改"><a href="#七-const-常量到能否更改" class="headerlink" title="七.const 常量到能否更改"></a>七.const 常量到能否更改</h3><p><strong>上面提到，const声明的变量无法被修改</strong>，但是：</p><ul><li>如果我们使用 const 声明基本数据类型则无法被修改；</li><li>如果我们使用 const 声明引用数据类型（‘即’对象）,这里的<strong>无法被修改</strong>指的是<font color=red>不能改变内存地址的引用；但是内容是可以被修改的</font><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如</span></span><br><span class="line"><span class="keyword">const</span> obj&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xichenghui&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;hhh&#x27;</span>&#125;<span class="comment">//可以修改成功</span></span><br><span class="line"><span class="comment">//但是我们不能修改它的引用地址，比如obj.name 我们不能修改成为 obj.nameDemo</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>因为 变量名 obj 是保存在<code>栈内存</code>中的，它代表的是对象的引用地址，它是基本的数据类型，无法被修改。但是obj 里面的内容是保存在 <code>堆内存</code>中的，它是引用数据类型，可以被修改</strong></p><p>tips:有不足之处，还请多多指教</p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
          <category> 学习 </category>
          
          <category> 面试 </category>
          
          <category> Web前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让一个元素居中显示？</title>
      <link href="/2022/10/28/%E5%AD%A6%E4%B9%A0/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA%EF%BC%9F/"/>
      <url>/2022/10/28/%E5%AD%A6%E4%B9%A0/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>让元素标准垂直居中显示是一个老生常谈的问题了的，今天我们来看看它们有哪些方式。<br>元素又包括 ： 行内元素和块级元素。</p><h2 id="行内元素居中"><a href="#行内元素居中" class="headerlink" title="行内元素居中"></a>行内元素居中</h2><pre><code>行内元素（比如文字，图片等）</code></pre><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> * &#123;//真实的盒子大小</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">//先给父元素设置,center  这会使元素水平居中</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">//让文字的行高等于盒子的高度，也可以让单行的文本垂直居中</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">30px</span>;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="块级元素垂直水平居中"><a href="#块级元素垂直水平居中" class="headerlink" title="块级元素垂直水平居中"></a>块级元素垂直水平居中</h2><p>Tip:块级元素垂直居中的方法就多了好多。</p><h3 id="第一种：绝对定位-margin-这种方式存在弊端，我们需要指定子元素的宽高。且盒子的大小，盒子的位置都需要手动去调节，比较麻烦。"><a href="#第一种：绝对定位-margin-这种方式存在弊端，我们需要指定子元素的宽高。且盒子的大小，盒子的位置都需要手动去调节，比较麻烦。" class="headerlink" title="第一种：绝对定位 + margin 这种方式存在弊端，我们需要指定子元素的宽高。且盒子的大小，盒子的位置都需要手动去调节，比较麻烦。"></a>第一种：绝对定位 + margin 这种方式存在弊端，我们需要指定子元素的宽高。且盒子的大小，盒子的位置都需要手动去调节，比较麻烦。</h3> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">           <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">//父盒子</span><br><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line"><span class="attribute">position</span>:relative;</span><br><span class="line"><span class="attribute">min-height</span>:<span class="number">500px</span>;</span><br><span class="line"><span class="attribute">background</span>:green;</span><br><span class="line">&#125;</span><br><span class="line">//子盒子</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">backgound:black;</span><br><span class="line"><span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin-top</span>:-<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>:-<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种-绝对定位-translate-无需指定子元素的宽高。可以使用-原理是，translate-函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的（动态计算宽高）"><a href="#第二种-绝对定位-translate-无需指定子元素的宽高。可以使用-原理是，translate-函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的（动态计算宽高）" class="headerlink" title="第二种:绝对定位  + translate  无需指定子元素的宽高。可以使用,原理是，translate()函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的（动态计算宽高）"></a>第二种:绝对定位  + translate  无需指定子元素的宽高。可以使用,原理是，translate()函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的（动态计算宽高）</h3> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">         <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">         <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     //父元素</span><br><span class="line">     <span class="selector-class">.father</span>&#123;</span><br><span class="line">     <span class="attribute">position</span>:relative;</span><br><span class="line">     <span class="attribute">min-height</span>:<span class="number">500px</span>;</span><br><span class="line">     <span class="attribute">background</span>:green;</span><br><span class="line">     &#125;</span><br><span class="line">     //子元素</span><br><span class="line">     <span class="selector-class">.son</span>&#123;</span><br><span class="line">     <span class="attribute">position</span>:absolute;</span><br><span class="line">     <span class="attribute">background</span>:red;</span><br><span class="line">     <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">     <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">     <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="第三种：flex布局-margin-auto-此方法最常用，它会让我们指定的子元素在剩余空间里，水平垂直的居中，在使用前需要先给父元素使用display-flex-再在子元素中设置margin-auto-即可。"><a href="#第三种：flex布局-margin-auto-此方法最常用，它会让我们指定的子元素在剩余空间里，水平垂直的居中，在使用前需要先给父元素使用display-flex-再在子元素中设置margin-auto-即可。" class="headerlink" title="第三种：flex布局 + margin:auto  此方法最常用，它会让我们指定的子元素在剩余空间里，水平垂直的居中，在使用前需要先给父元素使用display:flex; 再在子元素中设置margin:auto;,即可。"></a>第三种：flex布局 + margin:auto  此方法最常用，它会让我们指定的子元素在剩余空间里，水平垂直的居中，在使用前需要先给父元素使用<code>display:flex;</code> 再在子元素中设置<code>margin:auto;</code>,即可。</h3> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">          <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">          <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.father</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:flex;</span><br><span class="line"><span class="attribute">min-height</span>:<span class="number">100vh</span>;</span><br><span class="line"><span class="attribute">background</span>:green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>:auto;</span><br><span class="line"><span class="attribute">background</span>:black;</span><br><span class="line">&#125;</span><br><span class="line">//我们也可以给父元素加上`<span class="attribute">justify-content</span>:center`和`ailgn-items:center;`（<span class="attribute">display</span>:flex;前提下）,</span><br><span class="line">但是这会使其中的所有子元素都水平垂直居中，`<span class="attribute">display</span>：<span class="attribute">flex</span>;`会使父元素中的子元素压缩，</span><br><span class="line">使之不溢出屏幕，这时候使用`<span class="attribute">overflow</span>：scroll；`属性便会失效</span><br></pre></td></tr></table></figure><pre><code> 这就是常见的几种水平垂直居中方式了，希望能帮上各位。这时候，我们需要考虑如何给移动端设置一个红包弹出页面。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web前端 </category>
          
          <category> CSS </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3选择器</title>
      <link href="/2022/10/28/%E5%AD%A6%E4%B9%A0/CSS/CSS3%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2022/10/28/%E5%AD%A6%E4%B9%A0/CSS/CSS3%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><pre><code>CSS选择器有：</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div标签选择器  ， </span><br><span class="line">.box 类名选择器 ，</span><br><span class="line"> #box id选择器 ，</span><br><span class="line"> div p 后代选择器 ，</span><br><span class="line"> div.box 交集选择器 ，</span><br><span class="line"> div,p,span 并集选择器 （交同并异） ,</span><br><span class="line"> div &gt;p 子代选择器  ，</span><br><span class="line">  * ：通配符  ,</span><br><span class="line"> div+p: 选择div后面的相邻的第一个p，</span><br><span class="line"> div~p: 选中的div后面的所有p；</span><br><span class="line">选择器权重：ID选择器 &gt; 类选择器 &gt; 标签选择器</span><br></pre></td></tr></table></figure><p><strong>注意：！important 是给一个属性（比如：color:red;）增加权重（无穷大），而不是给该选择器提升<code>权重</code></strong></p><h2 id="CSS3新增的选择器"><a href="#CSS3新增的选择器" class="headerlink" title="CSS3新增的选择器"></a>CSS3新增的选择器</h2><pre><code>CSS3选择器增加了许多灵活的查找元素的方法，提高了我们查找元素的效率和`准确度`。</code></pre><h3 id="CSS3属性选择器"><a href="#CSS3属性选择器" class="headerlink" title="CSS3属性选择器"></a><font color="red">CSS3属性选择器</font></h3><pre><code> 其标志性符号是`[ ]`。 **匹配的含义**： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^:开头  $:结尾  *:包含</span><br></pre></td></tr></table></figure> **格式：** </code></pre><ul><li><code>A[url]</code> 选中页面的A元素，并且A元素要存在<code>url属性</code></li><li><code>A[url=&quot;/demo.jpg&quot;]</code>选中页面的A元素，并且A需要存在<code>url属性</code>,并且属性值<strong>完全等于</strong>/demo.jpg.</li><li><code>A[attr~=val]</code>   选择具有 att 属性且属性值为：用空格分隔的字词列表，其中一个等于 val 的A元素。</li><li><code>A[attr|=val]</code> 表示要么是一个单独的属性值，要么这个属性值是以”-“ 分割的</li><li><code>A[title^=&quot;abc&quot;]</code> 选中页面开头的A元素，并且A元素需要带有title属性，属性值以<code>abc</code>开头</li><li>A[title$=”abc”]` 选中页面开头的A元素，并且A元素需要带有title属性，属性值以abc结尾</li><li> A[title*=”abc”]` 选中页面开头的A元素，并且A元素需要带有title属性，属性值中存在abc.</li></ul><p> <strong>Tips：当我们需要精准选择某个属性时，使用属性选择器去匹配className,是一件很方便的事情。</strong></p><h3 id="伪类结构选择器"><a href="#伪类结构选择器" class="headerlink" title="伪类结构选择器"></a><font color="red">伪类结构选择器</font></h3><p>   伪类选择器的标志符号是<code>:</code>。<br> 在CSS中的伪类选择器有：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:link , :visted, :hover , :active , :focus</span><br></pre></td></tr></table></figure><br> CSS3新增了其他的伪类选择器。</p><h4 id="类型一"><a href="#类型一" class="headerlink" title="类型一"></a>类型一</h4><p> <strong>格式：</strong></p><ul><li><code>A:first-child</code> 匹配父元素的第一个子元素A;</li><li><code>A:last-child</code> 匹配父元素的最后一个元素A;</li><li><code>A:nth-child(n)</code> 匹配父元素的第n元素A,注意：盒子的编号是从<code>1</code>开始算起，而不是从<code>0</code>开始算起</li><li><code>A:nth-child(odd)</code> 匹配奇数盒子</li><li><code>A:nth-child(even)</code> 匹配偶数盒子</li><li><code>A:nth-last-child(n)</code> 匹配父元素的倒数第n个子元素A;<br>tips:<code>A:nth-child(n)</code>中的<code>n</code>表示0,1,2,3,4,5,6,7,8……,那么<code>2n</code>表示第<code>2n</code>偶数个元素，<code>2n+1</code>表示第<code>2n+1</code>奇数个元素等等用法。</li></ul><hr><h4 id="类型二"><a href="#类型二" class="headerlink" title="类型二"></a>类型二</h4><p> <strong>格式：</strong></p><ul><li><code>B:first-of-type</code> 匹配同类型中的第一个同级兄弟元素B</li><li><code>B:last-of-type</code> 匹配同类型中的最后一个同级元素B</li><li><code>B:nth-of-type(n)</code> 匹配同类型中的第n个同级元素B</li><li><code>B:nth-last-of-type(n)</code> 匹配同类型中的倒数第n个同级兄弟元素</li></ul><p>tips:我是这样理解的，先找到所有同类型的B,然后再根据<code>n</code>来进行匹配。</p><hr><h4 id="类型三"><a href="#类型三" class="headerlink" title="类型三"></a>类型三</h4><p> <strong>格式：</strong></p><ul><li><code>C:empty</code>匹配没有任何子节点（包括空格等text节点）的元素C</li><li><code>C:target</code> 匹配相关的URL指向的C元素，配合锚点使用</li></ul><p> <strong><font color="red">CSS3伪元素选择器</font></strong><br>伪元素选择器的标志性符号是<code>::</code>。<br><strong>1.格式：一</strong></p><ul><li><code>D::before</code> 设置在 元素D 前面（根据对象树的逻辑结构）的内容，需要配合content属性一起使用</li><li><code>D::after</code> 设置在 元素D 后面（根据对象树的逻辑结构）的内容，需要配合content属性一起使用。</li><li><code>D:after</code>，<code>D:before</code>在旧版本的时候是伪类，在CSS3中是会被当做<code>D::after</code>，<code>D::before</code>伪元素处理的,为的是兼容性处理</li></ul><p><strong>2、格式：二</strong></p><ul><li><p><code>E::first-letter</code> 设置元素 E 里面的<strong>第一个字符</strong>的样式。</p></li><li><p><code>E::first-line</code> 设置元素 E 里面的<strong>第一行</strong>的样式。</p></li><li><p><code>E::selection</code> 设置元素 E 里面被鼠标选中的区域的样式（一般设置颜色和背景色）。</p></li></ul><p>参考内容：千古一号，菜鸟教程，w3cSchool</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中的BFC——边距重叠解决方案</title>
      <link href="/2022/10/28/%E5%AD%A6%E4%B9%A0/CSS/CSS%E4%B8%AD%E7%9A%84BFC%E2%80%94%E2%80%94%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/10/28/%E5%AD%A6%E4%B9%A0/CSS/CSS%E4%B8%AD%E7%9A%84BFC%E2%80%94%E2%80%94%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC的概念"><a href="#BFC的概念" class="headerlink" title="BFC的概念"></a>BFC的概念</h2><pre><code>    BFC(Block Formatting Conrtext):块级格式化上下文 ，我们可以把它理解成一个独立的大盒子。    Tips:IFC(Inline Formatting Context) 直译为内联格式化上下文.理解即可</code></pre><h2 id="BFC的原理-BFC的布局规则（熟记）"><a href="#BFC的原理-BFC的布局规则（熟记）" class="headerlink" title="BFC的原理/BFC的布局规则（熟记）"></a>BFC的原理/BFC的布局规则（熟记）</h2><ol><li>BFC内部的子元素，在垂直方向，边距会发生重叠</li><li>BFC在页面是一个独立的容器，外面的容器是不会影响到里面的元素的，反之亦然</li><li>BFC区域是不会与旁边的float box 区域重叠的，它常被用来清除浮动带来的影响。</li><li>计算BFC的高度时，浮动的子元素也会参与计算（比如一个父元素<code>div</code>里面没有高度，但是加上overflow，就会使其变为BFC，从而计算父元素<code>div</code>的高度为该浮动元素的高度）</li></ol><h2 id="说了那么多，那我们如何生成BFC呢-？"><a href="#说了那么多，那我们如何生成BFC呢-？" class="headerlink" title="说了那么多，那我们如何生成BFC呢 ？"></a>说了那么多，那我们如何生成BFC呢 ？</h2><pre><code>常用方法有下列几种：</code></pre><ol><li>方法一：<code>overflow</code>:不为visible,可以让属性是hidden，auto。就可以使元素变为BFC</li><li>方法二:在定位之中：只要<code>position</code>的值不是static或者是relative即可，可以是absolute 或 fixed ，也就生成了一个BFC.</li><li>方法三：在浮动之中：float的属性值不为none。只要我们使用了浮动属性，当前元素就创建了BFC.</li><li>方法四：当display为：inline-block,table-cell,table-caption,flex,inline-flex</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;f&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;s&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//这样父元素和子元素会发生margin重叠，我们需要给子元素创建一个BFC,方可解决：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;f&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;s&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow:hidden&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6箭头函数</title>
      <link href="/2022/10/28/%E5%AD%A6%E4%B9%A0/JS/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2022/10/28/%E5%AD%A6%E4%B9%A0/JS/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>今天，我们从几个问题入手，了解ES6箭头函数</strong></p><h3 id="ES6箭头函数是什么？"><a href="#ES6箭头函数是什么？" class="headerlink" title="ES6箭头函数是什么？"></a>ES6箭头函数是什么？</h3><ul><li>ES6箭头函数怎么用？</li><li>ES6的箭头函数的this指向？</li><li>ES6箭头函数面试题。<h2 id="一-，ES6箭头函数是什么？"><a href="#一-，ES6箭头函数是什么？" class="headerlink" title="一 ，ES6箭头函数是什么？"></a>一 ，ES6箭头函数是什么？</h2></li></ul><p><strong>ES6</strong>中允许使用=&gt;来定义函数。箭头函数相当于匿名函数，并简化了函数的定义，其好处有 <strong>简明的语法</strong>,<strong>隐式返回</strong>，<strong>不绑定this</strong></p><h2 id="二，ES6箭头函数怎么用？"><a href="#二，ES6箭头函数怎么用？" class="headerlink" title="二，ES6箭头函数怎么用？"></a>二，ES6箭头函数怎么用？</h2><h3 id="箭头函数的语法"><a href="#箭头函数的语法" class="headerlink" title="箭头函数的语法:"></a>箭头函数的语法:</h3> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">（参数一，参数二 ...）=&gt;&#123;函数体&#125;</span><br></pre></td></tr></table></figure><p> Tips:</p><ul><li>如果形参只有一个时，可以省略小括号</li><li>函数体如果只有一条语句时，则花括号可以省略，函数的返回值为该条语句的执行结果。<h3 id="形参只有一个，省略小括号的情况"><a href="#形参只有一个，省略小括号的情况" class="headerlink" title="形参只有一个，省略小括号的情况"></a>形参只有一个，省略小括号的情况</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当形参只有一个参数时，注意，当没有参数时，小括号不可省略</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">demo</span> = num =&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> num +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">demo</span>(<span class="number">1</span>));<span class="comment">//返回结果为 2；</span></span><br></pre></td></tr></table></figure><h3 id="函数体只有一条语句的情况"><a href="#函数体只有一条语句的情况" class="headerlink" title="函数体只有一条语句的情况"></a>函数体只有一条语句的情况</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">demo</span> = (<span class="params">a,b</span>) =&gt;  a + b;<span class="comment">//此时，a+b默认为return的值，可省略return</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">demo</span>(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//输出结果为 3;</span></span><br></pre></td></tr></table></figure><h3 id="两种情况都存在时"><a href="#两种情况都存在时" class="headerlink" title="两种情况都存在时"></a>两种情况都存在时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">demo</span> = a =&gt; a + <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">demo</span>(<span class="number">1</span>));<span class="comment">//输出结果为 1;</span></span><br></pre></td></tr></table></figure><h2 id="三，ES6的箭头函数的this指向？"><a href="#三，ES6的箭头函数的this指向？" class="headerlink" title="三，ES6的箭头函数的this指向？"></a>三，ES6的箭头函数的this指向？</h2>箭头函数，不仅仅是为了让函数更加优美简洁，还有一个作用是与<strong>this</strong>的指向有关</li></ul><p><font color=red>ES6之前的普通函数中：</font>this的指向是函数被调用的对象，谁调用了函数，this就会指向谁。</p><p><font color=red>ES6的箭头函数中：</font>箭头函数本身<strong>不绑定</strong>this,this的指向是箭头函数定义位置的this。比如this箭头函数在哪个位置定义的，this就和这个位置的this指向相同。    </p><p><strong>代码举例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = &#123;<span class="attr">name</span>:<span class="string">&#x27;西城辉&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//第一个 this,输出结果:&#123;name:&#x27;西城辉&#x27;&#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//第二个 this ,输出结果:&#123;name:&#x27;西城辉&#x27;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> demo2 = fn1.<span class="title function_">call</span>(demo);<span class="comment">// 改变fn1的指向至demo </span></span><br></pre></td></tr></table></figure><p>代码解释:上面代码我们可以看到，箭头函数是在fn1()函数里面定义的，<strong>所以，第二个this和第一个this的指向是同一个位置</strong>。且，我们通过 fn2 将this指向demo,所以*<em>第一个this和第二个this</em>指向的都是demo。</p><h2 id="四，ES6箭头函数面试题"><a href="#四，ES6箭头函数面试题" class="headerlink" title="四，ES6箭头函数面试题"></a>四，ES6箭头函数面试题</h2><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;西城辉&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;胡歌&#x27;</span>,</span><br><span class="line"><span class="attr">hello</span>:<span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">hello</span>();</span><br></pre></td></tr></table></figure><p><strong>问</strong>：上面箭头函数输出的名字是谁的？</p><p><strong>答案：</strong>上面的打印结果是<strong>西城辉</strong>，为什么呢？因为<strong>obj</strong>这个对象并不产生作用域，所以hello() 这个箭头函数仍然是定义在<font color=red>window</font>中的,所以这里的this 指向是window.</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS遍历数组和对象的方法</title>
      <link href="/2022/10/28/%E5%AD%A6%E4%B9%A0/JS/JS%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2022/10/28/%E5%AD%A6%E4%B9%A0/JS/JS%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="JS遍历数组的方法有"><a href="#JS遍历数组的方法有" class="headerlink" title="JS遍历数组的方法有:"></a>JS遍历数组的方法有:</h2><ol><li>for</li><li>forEach</li><li>for…in</li><li>for…of</li><li>map<hr></li></ol><h2 id="JS遍历对象的方法有"><a href="#JS遍历对象的方法有" class="headerlink" title="JS遍历对象的方法有:"></a>JS遍历对象的方法有:</h2><ol><li>for…in</li><li>Object.keys</li><li>Object.getOwnPropertyNames(obj)<hr></li></ol><h2 id="JS遍历数组"><a href="#JS遍历数组" class="headerlink" title="JS遍历数组"></a>JS遍历数组</h2><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h3> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* for 普通的for循环,遍历数组 */</span></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>;i &lt; arr.<span class="property">length</span>;i ++)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;for遍历&#x27;</span>,arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 当数据过多时，可以将长度缓存起来，避免重复获取长度，数组很大时，优化效果明显 */</span></span><br><span class="line">      <span class="comment">// for(var j = 0,len = arr.length; j &lt; len; j++)&#123;</span></span><br><span class="line">      <span class="comment">//     console.log(arr[j]);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-forEach循环-ES5新增"><a href="#2-forEach循环-ES5新增" class="headerlink" title="2.forEach循环(ES5新增)"></a>2.forEach循环(<font color=red><strong>ES5新增</strong></font>)</h3> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* forEach 数组自带的循环，遍历数组  */</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">       arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value,i</span>)&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;forEach遍历&#x27;</span>,i,value);</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h3 id="3-for…in-不推荐遍历数组"><a href="#3-for…in-不推荐遍历数组" class="headerlink" title="3.for…in(不推荐遍历数组)"></a>3.for…in(<font color=red><strong>不推荐遍历数组</strong></font>)</h3><pre><code> for...in是es5标准，此方法遍历数组的效率比较低，主要用来循环遍历**对象的属性**</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[item])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-for…of-ES6新增"><a href="#4-for…of-ES6新增" class="headerlink" title="4.for…of(ES6新增)"></a>4.for…of(<font color=red><strong>ES6新增</strong></font>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es6新出的方法，for…of ，值得注意的是，for…of 和 for…in不一样，for…in是直接获取数组的索引，而for…of是直接获取的数组的值。<br>它既比传统的for循环简洁，同时弥补了forEach和for-in循环的短板。<br>循环遍历键值对的value，与for in遍历key相反</p><h3 id="5-map-ES6新增"><a href="#5-map-ES6新增" class="headerlink" title="5.map(ES6新增)"></a>5.map(<font color=red><strong>ES6新增</strong></font>)</h3><pre><code>     map是映射的意思，原数组会被映射成对应的新数组</code></pre> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]; </span><br><span class="line"> <span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>( <span class="keyword">function</span>(<span class="params">value,index</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value + <span class="string">&#x27;--&#x27;</span> + index)</span><br><span class="line"><span class="keyword">return</span> value+<span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//1,2,3,4,5,6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);<span class="comment">//2,3,4,5,6,7</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:从上面的代码我们可以发现，map支持return,相当于把原数组克隆了<br>一份，把克隆的每项都改变了，也不会影响原数组；<br> <hr></p><h2 id="JS遍历对象的方法有-1"><a href="#JS遍历对象的方法有-1" class="headerlink" title="JS遍历对象的方法有"></a>JS遍历对象的方法有</h2><h3 id="1-for…in遍历对象-常用"><a href="#1-for…in遍历对象-常用" class="headerlink" title="1.for…in遍历对象(常用)"></a>1.for…in遍历对象(<font color=red><strong>常用</strong></font>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;西城辉&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line"><span class="attr">job</span>:<span class="string">&#x27;student&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;:&#x27;</span> + obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Object-keys-遍历对象"><a href="#2-Object-keys-遍历对象" class="headerlink" title="2.Object.keys 遍历对象"></a>2.Object.keys 遍历对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;西城辉&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line"><span class="attr">job</span>:<span class="string">&#x27;student&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj))&#123;<span class="comment">//for  of 不能单独来遍历对象，要结合Object.keys一起使用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;:&#x27;</span> + obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Object-getOwnPropertyNames-obj-遍历对象"><a href="#3-Object-getOwnPropertyNames-obj-遍历对象" class="headerlink" title="3.Object.getOwnPropertyNames(obj)遍历对象"></a>3.Object.getOwnPropertyNames(obj)遍历对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;西城辉&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line"><span class="attr">job</span>:<span class="string">&#x27;student&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key+ <span class="string">&#x27;:&#x27;</span> +obj[key]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>返回一个数组，包含对象自身的所有属性（包含不可枚举属性） 遍历可以获取key和value</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题一</title>
      <link href="/2022/10/28/%E5%AE%9E%E6%88%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
      <url>/2022/10/28/%E5%AE%9E%E6%88%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 文章写作</title>
      <link href="/2022/10/24/%E5%AD%A6%E4%B9%A0/hexo%20%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/10/24/%E5%AD%A6%E4%B9%A0/hexo%20%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="今天我们来学习如何使用hexo里面的语法进行写作"><a href="#今天我们来学习如何使用hexo里面的语法进行写作" class="headerlink" title="今天我们来学习如何使用hexo里面的语法进行写作"></a>今天我们<span id="more"></span>来学习如何使用hexo里面的语法进行写作</h2><!-- 多余的内容不会出现 --><h3 id="hexo文章属性"><a href="#hexo文章属性" class="headerlink" title="hexo文章属性"></a>hexo文章属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title【必需】页面标题</span><br><span class="line">date【必需】页面创建日期</span><br><span class="line">type【必需】标籤、分类和友情链接三个页面需要配置</span><br><span class="line">updated【可选】页面更新日期</span><br><span class="line">description【可选】页面描述</span><br><span class="line">keywords【可选】页面关键字</span><br><span class="line">comments【可选】显示页面评论模块(默认 true)</span><br><span class="line">top_img【可选】页面顶部图片</span><br><span class="line">mathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br></pre></td></tr></table></figure><h3 id="以下是实例代码"><a href="#以下是实例代码" class="headerlink" title="以下是实例代码"></a>以下是实例代码</h3><p><em>注意</em>：可以直接使用markdown的语法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> code = <span class="string">&quot;demo&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>普通的代码块</strong><br><em>hexo语法</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock %&#125;</span><br><span class="line">alert(&#x27;Hello World!&#x27;);</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&#x27;Hello World!&#x27;);</span><br></pre></td></tr></table></figure><p><strong>指定语言的代码块</strong><br><em>hexo语法</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:js %&#125;</span><br><span class="line">let demo = &quot;walcome to my home&quot;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> demo = <span class="string">&quot;walcome to my home&quot;</span></span><br></pre></td></tr></table></figure><p><strong>颜色字体演示</strong><br><font color=red>我是红色</font></p><p><em>代码：</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=red&gt;我是红色&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><strong>在文章中插入图片演示</strong><br><em>方法一(在线链接):</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![西城辉](图片url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202009%2F02%2F20200902095413_yaBAK.thumb.1000_0.jpeg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1669533944&t=2956ac182a54ebe59208821023613cd2" alt="西城辉"></p><p><em>方法一(本地图片):</em><br>图片存放在source/images/图片中<br><img src="/images/seaside.jpg" alt="西城辉"></p><p><strong>在文章中插入链接演示</strong></p><h3 id="这是一次尝试"><a href="#这是一次尝试" class="headerlink" title="这是一次尝试"></a>这是一次尝试</h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Hexo写作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程初心</title>
      <link href="/2022/10/22/%E8%A5%BF%E5%9F%8E%E8%BE%89%E7%9A%84%E5%B0%8F%E8%AF%9D/%E5%88%9D%E5%BF%83/"/>
      <url>/2022/10/22/%E8%A5%BF%E5%9F%8E%E8%BE%89%E7%9A%84%E5%B0%8F%E8%AF%9D/%E5%88%9D%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到西城辉的小站</p>]]></content>
      
      
      <categories>
          
          <category> 西城辉的小话 </category>
          
          <category> 初心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初心 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
